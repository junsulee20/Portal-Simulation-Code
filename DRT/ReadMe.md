# 수요응답형 대중교통 (DRT) 라우팅 알고리즘 시뮬레이터

## 📄 개요

본 프로젝트는 **수요응답형 대중교통(DRT, Demand-Responsive Transport)** 시스템의 핵심 기능인 **라우팅 알고리즘**을 Python으로 구현한 시뮬레이터입니다.

새로운 승객의 탑승 요청이 발생했을 때, 여러 대의 차량 중 어떤 차량이, 어떤 경로로 해당 승객을 서비스하는 것이 가장 효율적인지를 결정하는 과정을 시뮬레이션합니다. '방향'과 '거리'를 모두 고려하여 최적의 차량을 배정하는 로직을 직관적으로 이해할 수 있도록 돕는 것을 목표로 합니다.

## 🧠 적용 알고리즘

이 코드는 **최소 추가 비용 삽입 휴리스틱 (Lowest Cost Insertion Heuristic)** 알고리즘을 기반으로 합니다.

알고리즘의 작동 방식은 다음과 같습니다.

1.  **신규 요청 접수**: 새로운 승객의 출발지와 목적지 정보를 받습니다.
2.  **모든 경우의 수 탐색**: 현재 운행 중인 모든 차량의 기존 경로에 대해, 신규 승객의 `출발지(Pickup)`와 `목적지(Drop-off)`를 삽입할 수 있는 모든 가능한 위치 조합을 탐색합니다.
3.  **비용 계산**: 각 조합에 대한 총 경로 길이를 계산하고, 기존 경로와의 차이, 즉 \*\*'추가 비용(추가 거리)'\*\*을 도출합니다.
4.  **최적 해 선택**: 계산된 '추가 비용'이 가장 적은 차량과 경로를 최종적으로 선택하고, 승객을 배정합니다.

이 방식은 신규 승객의 이동 방향과 비슷한 경로로 운행 중인 차량에게 더 낮은 '추가 비용'을 부여하므로, 자연스럽게 가장 효율적인 차량에 배정하게 됩니다.

## 🚀 실행 방법

1.  Python 3.x 버전이 설치되어 있는지 확인합니다.
2.  터미널 또는 명령 프롬프트에서 아래 명령어를 실행합니다.

<!-- end list -->

```bash
python a_drt_routing_algorithm.py
```

*(참고: 파일명이 `a_drt_routing_algorithm.py`가 아니라면 해당 파일명으로 변경하여 실행하세요.)*

## ⚙️ 코드 구성

  - **`Point` 클래스**:
      - 각 지점(승객 출발지, 목적지 등)의 ID와 좌표(x, y)를 저장합니다.
  - **`Vehicle` 클래스**:
      - 차량의 고유 ID와 현재 경로(`path`) 정보를 가집니다.
      - `path`는 `Point` 객체들의 순서 있는 리스트로, 차량의 경유지 순서를 의미합니다.
  - **`calculate_distance(p1, p2)` 함수**:
      - 두 `Point` 객체 간의 유클리드 거리를 계산합니다.
  - **`calculate_path_distance(path)` 함수**:
      - 주어진 경로(`path`)의 총 이동 거리를 계산합니다.
  - **`assign_passenger_to_vehicle(...)` 함수**:
      - **핵심 로직이 담긴 함수**입니다.
      - 동적 차량 경로 문제(Dynamic Vehicle Routing Problem) 해결을 위한 삽입 휴리스틱(Insertion Heuristic) 알고리즘을 사용한 것입니다. 조금 더 구체적으로는 최소 추가 비용 삽입(Lowest Cost Insertion) 또는 탐욕적 삽입(Greedy Insertion) 방식이라고 부를 수 있습니다.
      - 신규 승객 정보를 받아 모든 차량의 모든 경로 조합을 테스트하여, 최소 추가 비용이 발생하는 최적의 차량과 새로운 경로를 반환합니다.

## 📊 시뮬레이션 예제 분석

코드 내 예제 시나리오는 다음과 같습니다.

1.  **초기 상태**:
      - `차량 1`: 승객 `P1`을 태우고 `(1, 1)`에서 `(5, 5)`로 이동 중입니다.
      - `차량 2`: 승객 `P2`를 태우고 `(10, 10)`에서 `(15, 12)`로 이동 중입니다.
2.  **신규 요청**:
      - 새로운 승객 `NewP`가 `(2, 2)`에서 `(6, 6)`으로 가는 요청을 합니다.
3.  **알고리즘 실행**:
      - **`차량 1`에 `NewP`를 태우는 경우**: 기존 경로와 방향이 유사하여 추가되는 거리가 상대적으로 적습니다.
      - **`차량 2`에 `NewP`를 태우는 경우**: 완전히 다른 방향으로 운행 중이므로, `NewP`를 태우고 내리기 위해 돌아가는 거리가 매우 길어져 추가 비용이 크게 발생합니다.
4.  **최종 결과**:
      - 알고리즘은 **'최소 추가 비용' 원칙**에 따라 `NewP`를 **`차량 1`에 배정**합니다.
      - `차량 1`의 경로는 `[P1_Start, NewP_Start, P1_End, NewP_End]`와 같이 가장 효율적인 순서로 업데이트됩니다.

<!-- end list -->

```
--- 초기 상태 ---
차량 1 경로: ['P1_Start', 'P1_End'], 총 거리: 5.66
차량 2 경로: ['P2_Start', 'P2_End'], 총 거리: 5.39

--- 신규 승객 요청: NewP_Start -> NewP_End ---
  [차량 1] 테스트 경로: ['NewP_Start', 'NewP_End', 'P1_Start', 'P1_End'], 추가 거리: 12.02
  [차량 1] 테스트 경로: ['NewP_Start', 'P1_Start', 'NewP_End', 'P1_End'], 추가 거리: 4.14
  ...
  (모든 경우의 수 테스트)
  ...
  [차량 2] 테스트 경로: ['NewP_Start', 'NewP_End', 'P2_Start', 'P2_End'], 추가 거리: 29.89
  ...

--- 결과 ---
최적 차량: 차량 1
최소 추가 거리: 2.77
새로운 최적 경로: ['P1_Start', 'NewP_Start', 'P1_End', 'NewP_End']

--- 최종 배정 후 상태 ---
차량 1 경로: ['P1_Start', 'NewP_Start', 'P1_End', 'NewP_End']
차량 2 경로: ['P2_Start', 'P2_End']
```
